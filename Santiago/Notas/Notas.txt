/*
Historia:
Creado por Sun Microsystems Inc. en el año 1995.
Fue creado por un grupo de trabajo liderado por James Gosling

Java es un lenguaje de desarrollo de poróposito general, siendo válido para realizar 
todo tipo de aplicaciones profesionales.

¿Qué lo hace distinto?
Los programas creados por Java son INDEPENDIENTES de la arquitectura (windows, mac)
Permite escribir Applets.
APPS INTRARREDES; CLIENTE/SERVIDOR

Se pueden programar Aplicaciones Independientes y applets

Applets (pequeños programas en html).


Es intrínsecamente Orientado a Objetos.
Tiene gran funcionalidad gracias a sus librerías
No tiene punteros manejables por el programador.
El manejo de memoria lo gestiona el propio lenguaje.
Genera aplicaciones con pocos errores posibles (riguroso)
Incorpora Multi- Threading (hilos)

VARIABLES:

TIPOS DE VARIABLES PRIMITIVAS EN JAVA:
    *Variable es un espacio de memoria donde asignas un valor:
    *No se puede poner null en primitivos
    ENTEROS:

        byte (ocupa 8 bits) va de -128 a 127 
        short (ocupa 16 bits) va de  -32.768 a 32.767
        int (ocupa 32) *Más utilizado* 
        long (64 bits)

    REALES:
        float (ocupa 32 beats) ##f; el f indica que es float
        double (ocupa 64 beats) NO necesita letra

    Caracteres:
        char 'simples'  ///// Recordar ejemplo hola = h  
                // metodos: Character.toUpperCase(caracter) //CONVIERTE EL CARACTER EN MAYUSCULAS
    
    DESICIÓN:
        boolean (true false)

TIPOS DE VARIABLES  NO PRIMITIVAS EN JAVA:
    *LOS DATOS NO PRIMITIVOS TIENE MÉTODOS, LOS PRIMITIVOS NO
    CADENAS:
        String palabra = "hola gononea"; // la palabra tiene metodos

            


CONSTANTES:
*Espacio de memoria que no va a cambiar NUNCA

    final int numero = 10; //constante SOLO ES PONER final


ENTRADA Y SALIDA DE DATOS:
    Consola: Scanner
    Sin consola: JOptionPane

OPERADORES ARITMÉTICOS:
    Residuo: num1  %  num2 
    Combinados:
        numero += 5  // le sumo 5 a la variable numero ===> numero = numero+5
        numero -= 5 // lo mismo en resta
        numero *= 5
        numero /= 5
        numero %=5
    Incremento: 
        x++ // es igual a x +1
        x-- // le resto 1

            EJEMPLO:
            int x=5;
            int y;

            y=x++;  // Si pongo ++x primero se suma 1 a x y luego y=x... por lo que y=6

            System.out.println(y); //da 5, primero se asigna y=x y despues se realiza la opción de x++
            System.out.println(x); // da 6

MATH:

    double raiz = Math.sqrt(9); // Raiz cuadrada
    int raiz2 = (int)Math.sqrt(9); //convertimos el double del sqrt a entero
    double base =5, exponente= 2;
    double respuesta = Math.pow(base, exponente); //exponencial
    double numero = 4.56;
    long redondea = Math.round(numero); //Sale 5, redondeo 4.56
    double numerorandom =Math.random();//random



CONDICIONALES:
    if/else:    //Condicionales Simples y dobles
        if(condicion){         //Para hacer un if compuesto de dos o mas condiciones debo colocar el &&
                               //Para hacer el operador "o" pongo  ||            
            instruccion1;
        }
        else{
            instruccion2;
        }

        ejemplo: 
        int numero, dato= 5;
        numero = Integer.parseInt(JOptionPane.showInputDialog("Digite un numero :"));  //convierto String en int

        if(numero == dato){    // == es que si el numero es IGUAL a dato
                               // != es que si el nuemro es DIFERENTE a dato 
                               // <= menor o igual que; >= mayor o igual que; 
            joptionpage.showMessageDialog(null,"El numero es 5");
        }
            else{
                JOptionPane.showMessageDialog(null, "El numero es diferente de 5");
        }

    switch: //Condicionales multiples
        switch(dato){
            case 1:Instrucciones1;
            break;
            case 2: Instrucciones;
            break;
            ...
            case n: Instrucciones n;
            break;
            default: CasoContrario;
            break;
        }

        EJEMPLO:
        int dato;
        dato0Integer.parseInt(JOptionPane.showMessageDialog("Digite un numero entre 1 y 3"));

        switch(dato){
            case 1: JOptionPane.showMessageDialog(null, "Es el numero 1");
                break; //cierra el código y la condicion, si no lo pongo, no sale de la sentencia switch hasta que encuentre un break
            case 2: JOptionPane.showMessageDialog(null, "Es el numero 2");
                break;
            case 3: JOptionPane.showMessageDialog(null, "Es el numero 3");
                break;
            default: JOptionPane.showMessageDialog(null, "El numero no está dentro del rango de 1 a 3");

        } 

    Operador Ternario:   //Forma inusual pero interesante
        valor = (Condicion) ? valor 1 : valor 2
        String mensaje;
        EJEMPLO:
        numero= Integer.parseInt(JOptionPane.showInputDialog("Digite un numero: "));       

        mensaje = (numero %2==0)? " Es par": "Es impar"; // *Numero dividido en dos tiene que dar de reciduo 0 ==>  SI ES PAR EL STRING "Es par" se guarda en mensaje.... si no se guarda el "Es impar"

        JOptionPane.showMessageDialog(null, mensaje);

CICLOS O BUCLES: 

    Ciclo While (mientras): //PRIMERO LA CONDICION DEBE CUMPLIRSE PARA CORRER EL BUCLE WHILE.
        while (condicion){     //MIENTRAS se cumplan las condiciones se va a repetir las intrucciones.
            instrucciones;
        }

        EJEMPLO:
        
        int i = 1;
        int contador;
        while (i<=10){
            System.out.println(i); // va a hacer 1, 2, 3, 4, ..., 10.
            i++    // avanza de 1 en 1... si quiero restar seria i--
        }

    Ciclo Do While:  //PRIMERO EJECUTA LAS INSTRUCCIONES Y DESPUES REVISA SI LA CONDICION SE CUMPLE
        do{
            Instrucciones;
        }while(condicion);

        EJEMPLO:

        int i = 111;

        do{
            System.out.println(i) // Primero imprime 11
            i++
        }while (i>=10);  //Luego ve que no se cumple la instruccion y no sigue el bucle.

    Ciclo For
        for (inicializacion; condicion; aumento o decremento){
            Instrucciones;
        }

        EJEMPLO:
        for(int i=1; i<=10; i++){     //no necesita un int i por fuera del bucle
            System.out.prinln(i); //Se imprime 1, 2, 3, ..., 10
            
        }       

ARRAYS (arreglos, vectores): Es una estructura de datos que nos permite almacenar un conjunto de datosde un mismo tipo.
*Posiciones contiguas de memoria.
*El tamaño de los arrays se declara en un primer momento y no puede cambiar luego durante la ejecucion del programa.

    Arrays Unidimencionales:
        Tipo_de_variable[] Nombre_del_array = new Tipo_de_variable[dimension];
        Ejemplo:
            int[] edad = new int[4];
            char[] sexo = new char[2];
    Dar valores:
        En caso de que queramos inicializarlos con valores propios, haremos esto:
            int[] numeros = new int[3]; //Array con 3 espacios
            // existen 2 formas:
                1. numeros[0]=5; //pone un 5 en el primer espacio del arreglo
                   numerso[1]=3; //pone un 3 en el segundo espacio del arreglo
                   numeros[2]=2;         
                2. int[] numeros = {5,7,9}; //Define los arreglos                        
    Leer el array:
        for (int i = 0; i<3;i++){
            System.out.println(numeros[i]); //Se imprime 5, 3 y 2
        }
    Llenar un arreglo:
        for (int i=0; i<nElementos;i++){
            System.out.print("");
            letras [i] = entrada.next().charAt(0);  //Se va llenando el array
        }
    
    FOR EACH (Otra manera de imprimir un arreglo de manera más eficaz y rapida):
        String [] nombres = {"Alejandro", "Juan", "Santiago"};

        for (int i=0;i<6;i++){  // Seria la forma de for, en donde conozco el numero de elementos que tiene el arreglo
            System.out.println(nombres[i]);
        }

        for (int i=0;nombres.length;i++){   //Con el length puedo desconocer el numero de datos del array... Eso lo hace por mi
            System.out.println(nombres[i]);
        }

        //AHORA SI, EL BUCLE FOR MEJORADO

        for (String i:nombres){  //Este es el for each, dice que dentro del interador i se vana a copiar todos los nombres que hay en el arreglo
            System.out.println(i);
        } //Para que pueda funcionar primero debo tener elementos en mi array SIEMPRE.

METODOS DE ORDENAMIENTO: (Ordenar los elementos de un arreglo):

    Metodo Burbuja (Es el algoritmo de ordenamiento mas sencillo, pero no el mas eficiente):
    *Funciona revisando cada elemento de la lista que va a ser ordenada con el siguiente, intercambiandolos de posicion si estan en un orden equivocado.
    *Va uno por uno... tal como me explico Nicolas
    *Los numeros más pequeños son los que van a subir a la superficie... como burbujas 
    
        //Ej: Si numeroActual> numeroSiguiente ==> cambio 
            45213 - 4 no es mayor a 5 pero 5 si es mayor a 2...
            42513 - 5 es mayor a 1
            42153 - 5 es mayor a 3
            42135 - 4 es mayor a 2 
            24135 - 4 es mayor a 2.. y a 3
            21345 - 2 es mayor a 1
            12345 - 2 no es mayor a 3 ni 3 es mayor a 4 ni 4 es mayor a 5... YA ESTA ORDENADO.
    
        AHORA EN CODIGO:

            Scanner entrada = new Scanner(Systema.in);
            int arreglo[];
            int nElementos;
            int aux;

            nElementos = Integer.parseInt(joptionpane.showInputDialog("Digite la cantidad del arreglo"));

            arreglo= new int [nElementos];

            for (int i=0; i<nElementos; i++){
                System.out.println((i+1)+". Digite un numero: ");
                arreglo[i]=entrada.nextInt();

            }

            //Metodo burbuja
            for (int i=0; i<(nElementos-1);i++){ //Se pone ese nElementos-1 porque no es necesario que el programa recorra todos los espacios del arreglo
                for (int j=0; j<(nElementos-1);j++){
                    if(arreglo[j]> arreglo[j+1]){ //Si numeroActual> numeroSiguiente
                        aux = arreglo[j];
                        arreglo[j] = arreglo [j+1];
                        arreglo [j+1] = aux;
                    }
                }
            }
            // Si lo quiero de forma decreciente solo falta imprimir el arreglo de atras para adelante jajaja.

    Ordenamiento por Insercion: (Requiere O(n^2) operaciones para ordenar una lista de n elementos):
        ejm:53412 (Hay una flecha que está "observando" el 5)
            53412 (En la izquierda de 5 hay un numero mayor a este? No... porque ni hay numero) 
                 (La flechita pasa al 3. Hay un numero mayor a su izquierda? SI ==> CAMBIO )
            35412 (El numero a la izquieda es mayor que 3? No... porque no existe)
                 (La flechita cambia al 4)
            ...
            34512 (La flechita esta en 1... la izquierda de 1 es mayor a este? Si ==> CAMBIO) 
            34152 (La izquierda de 1 siqgue siendo mayor ==>CAMBIO)
            ...
            13452 .... Y así 

        AHORA EN CODIGO:

            Scanner entrada = new Scanner(Systema.in);
            int arreglo[];
            int nElementos;
            int pos;
            int aux

            nElementos = Integer.parseInt(joptionpane.showInputDialog("Digite la cantidad del arreglo"));

            arreglo= new int [nElementos];

            for (int i=0; i<nElementos; i++){
                System.out.println((i+1)+". Digite un numero: ");
                arreglo[i]=entrada.nextInt();

            }

            //Ordenamiento por Insercion 
            for (int i=0; i<nElementos; i++){
                pos = i;
                aux = arreglo[i];

                while((pos>0) && (arreglo [pos-1]>aux)){
                    arreglo [pos] = arreglo [pos-1];
                    pos--;
                }
                arreglo [pos] = aux;
            }

    Ordenamiento por Seleccion:
        1. Buscar el minimo elemento de la lista.
        2. Intercambiar con el primer elemento.
        3. Buscar el minimo del resto de la lista.
        4. Intercambiarlo con el segundo.
        5. Seguir asi.

        AHORA EN CODIGO:

            Scanner entrada = new Scanner(Systema.in);
            int arreglo[];
            int nElementos;
            int aux;
            int min;

            nElementos = Integer.parseInt(joptionpane.showInputDialog("Digite la cantidad del arreglo"));

            arreglo= new int [nElementos];

            for (int i=0; i<nElementos; i++){
                System.out.println((i+1)+". Digite un numero: ");
                arreglo[i]=entrada.nextInt();

            }

            //Ordenamiento por Seleccion 
            for (int i=0; i<nElementos; i++){
                min = i;
                for (int j=i+1;j<nElementos; j++){
                    if (arreglo [j] < arreglo [min]){
                        min=j;
                    }
                }
                aux = arreglo[i];
                arreglo[i] = arreglo[min];
                arreglo[min]=aux;
            }

    Busquedas: 
        Busqueda Secuencial: (Buscar un determinado elemento en un array):
        *Algoritmo sencillo, no importa si está ordenado o no el array ya que va a buscar todas las posiciones del arreglo
        *No es muy eficiente

        CODIGO:
            int arreglo[]= {4,1,5,2,3};
            int dato;
            booleam band =false;

            dato= Integer.ParseInt (JOptionePane. showInputDialog("Digite el numero que quiere buscar"));

            //Busqueda Secuencial:
            int i =0;

            while(i<5 && band ==false){
                if (dato==arreglo[i]){
                    band = true;
                }
                i++
            }
            
            if (bandera==false){
                JOptionpage.showMessageDialog(null, "El numero no se encuentra en el arreglo");
            }else{
                JOptionePane.showMessageDialog(null, "El numero ha sido encontrado en la posicion "+ (i-1));
            }

        Busqueda Binaria:
        *Se utiliza cuando el arreglo está ordenado de forma ascendente
            CODIGO:
                int arreglo [] = {1,2,3,4,5}; //Esta en forma ascendente
                int dato, inf, sup, mitad, i=0; 
                boolean band =f alse;

            dato= Integer.ParseInt (JOptionePane. showInputDialog("Digite el numero que quiere buscar"));

            //Busqueda Secuencial:
            inf = 0;
            sup = 5;
            i = 0;

            mitad = (inf+sup)/2;

            while(inf<=sup && i<5){
                if (arreglo[mitad]==dato){
                    band =true;
                    break;
                }
                if (arreglo[mitad > dato]){
                    sup =mitad;
                    mitad =(inf+sup)/2
                }
                if (arreglo[mitad < dato]){
                    inf = mitad;
                    mitad =(inf+sup)/2
                }
                i++;
            }

            if (bandera==false){
                JOptionpage.showMessageDialog(null, "El numero no se encuentra en el arreglo");
            }else{
                JOptionePane.showMessageDialog(null, "El numero ha sido encontrado en la posicion "+ mitad);
            }

MATRICES: Es un arreglo bidimensional, que necesita dos indices para acceder a sus elementos.
*Algebra lineal ==> Tabla de n filas y m columnas cuyos elementos son todos del MISMO TIPO
*Es un "ARRAY DE ARRAYs... O arreglo de arreglos"

    CODIGO:
        
        // int matriz [][]={{1,2,3};{4,5,6};{7,8,9}}  //Esto seria una matriz de 3*3

        int matriz [][];
        int nFilas;
        int nColumnas;
        Scanner entrada= new Scanner (System.in);

        nFilas= Integer.parseInt(JOptionePane,showInputDialog("Digite el numero de filas del arreglo));
        nColumnas= Integer.parseInt(JOptionePane,showInputDialog("Digite el numero de filas del arreglo));  

        matriz = new int [nFilas][nColumnas];

        for (int i=0;i<nFilas;i++){   
            for (int j=0;j<3;j++){    
                System.out.print(matriz["+i+"]["+j+"]: ");
                matriz[i][j] = entrada.NextInt();          
            } 

            
        }

        System.out.println ("La matriz es: ")
        for (int i=0;i<nFilas;i++){   //numero de filas
            for (int j=0;j<nColumnas;j++){   //numero de columnas  
                System.out.print(matriz[i][j]);
            }   
            System.out.println("");
        }

POO:
    *No olvidar el metodo main:
        public static void main (String [] args){
    *Variables locales ==> Estan dentro del metodo
    *Variables globales ==> Estan en los atributos       
            
    Metodos: 
        metodos ==> public *void* (o int o lo que devuelva) nombreMetodo (){

            Parametros: Es una declaracion de variables u objeto.
                Se ponen en los () de la declaracion del metodo
           
           
            Argumento: Es un valor que se envia
                Se ponen en los () de la invocacion del metodo

        *Variables locales ==> Estan dentro del metodo
        *Variables globales ==> Estan en los atributos       
    
        }
        }

        Retorno de valores: 

            Ejm1: 
            public *int* sumar (int a, int b){   //El metodo suma va a devolver un int
                int suma = a+b;   // Se crea la variable suma
                return suma;    // Aquí me devuelve, me retorna el valor entero de suma
            }
            int suma =objeto.sumar(5,4);  //Para poder imprimir el valor entero utilizo la variable entera "suma"

            Ejm2:
            public String saludar (String nombre){
                String saludo = "hola" +nombre;
                return saludo;
            }
            String saludo = objeto.saludo("Alejandro");
            System.out.println(saludo);

    Constructores: Metodos especialess que NO especifican que devulven algo.
    *No olvidar que si el mombre del parametro es el mismo nombre del atributo se utiliza this.algo
    *this.algo (Es el atributo) = algo (es el argumento del constructor)

    Sobrecarga de metodos:
        *Sobrecarga de contructor (Hay mas de un constructor, con distintos parametros)
        EJM:

            String nombre;
            int edad; 
            String dni;

            public Persona(String dni, int edad){  
                this.nombre = nombre;
                this.edad = edad;
            }

            public Persona (String dni){  //Sobrecarga de constructores... Tener en cuenta que sus parametros son distintos
                this.dni=dni;
            }

            public void correr (){
                System.out.prinln("Soy"+nombre+ ", tengo "+edad+ "años y estoy corriendo una maraton" );
            }

            public void correr (int km){    //Sobrecarga de metodos. Tener en cuenta que tiene distintos parametros (cantidad o tipo) ya que de esta forma java puede diferenciarlos
                System.out.prinln("He corrido "+ km+ " kilometros );
            }

    Modificadores de Acceso = 
        CODIGO:
            package paquete1;
            public class Clase1 {
                int atributo;   //Tiene un modificador de uso por defecto por lo que no especifico nada
            }
            package paquete1;
            public class Clase2{
                public static void main(String[] args){
                    Clase1 objeto1= new Clase1();

                    objeto1.atributo1=15;  //Al ser el atributo1 del objeto1 un atributo que tiene un modificador de uso por defecto, puedo acceder desde otra clase y modificar ese atributo
                }
            }

            package paquete2; //otro paquete
            import paquete1.Clase1;  //Importo la clase de otro paquete
            public class Clase3{
                public static void main (String[]args){
                    Objeto1.atributo1=15;  //Pondria error, ya que el atributo 1, tiene un modificador de uso que si bien permite acceder a el desde clases del mismo paquete, no plo permitiria 
                                           ante clases de distintos paquetes... Para que si se pudiera tocaria poner en el atributo de la Clase1:
                                                    *public* int atributo;
                        
                }
            }
        
        Modificador de Acceso PRIVATE: Restringe el atributo para que solo pueda ser utilizado por metodos de la misma clase. Ninguna otra clase puede acceder a el.

ENCAPSULAMIENTO: Se encarga de ocultar nuestros atributos o nuestros metodos.
    *Encapsula los datos para uqe cualquiera no pueda cambiar los datos.
    
    Metodos accesores ==> Setters y Getters 

        Set (Significa establecer en ingles) ==> Vamos a establecer un atributo para mi variable.

        CODIGO:
            
            public Clase1{
                private int edad;

                public void setEdad (int edad){   //Establece la edad que manda el usuario 
                    this.edad =edad;
                }
            }    

            ///Otra clase

            public Clase2{
                Clase1 objeto1 = new Clase1();

                objeto1.setEdad(10);   //Establece que edad valga 10
            }

        Get (Obtener) ==>Mostramos la variable

        CODIGO:

            public Clase1{
                private int edad;

                public void setEdad (int edad){   //Establece la edad que manda el usuario 
                    this.edad =edad;   //Mirar el this
                }

                public int getEdad(){
                    return edad;     //Mirar el return
                }
            }    

            ///Otra clase

            public Clase2{
                Clase1 objeto1 = new Clase1();

                objeto1.setEdad(10);   //Establece que edad valga 10
                System.out.println("La edad es: "+ objeto1.getEdad); //Imprimo la edad (NO puedo poner + edad, sino el metodo getter)
            }

CONSTANTES: Variables que nunca cambian
    *private final  String miCosita; 

MIEMBROS ESTATICOS DE CLASE: //Toca repasar
    Atributos:
        *private static String frase ="Primera frase"  //Ya el atributo no le pertenece al objeto sino a la clase... por lo tanto todo cambio que yo le haga a este atributo 
                                                        en cualquier objeto va a cambiar en la clase (cambiandole a todos los objetos).      
        Ya no se necesita crear objetos para llamar los atributos de la clase.      
    Metodos:
        *public static int sumar (int n1, int n2){   //Los metodos estaticos tambien le pertenece a la clase, no a los objetos
        }

ESTUDIAR METODOS DE TIPO OBJETO    
*/
